{
  "categories": {
    "array": {
      "name": "Array",
      "description": "Problems involving array manipulation and algorithms",
      "questions": [
        {
          "id": 1,
          "title": "Two Sum",
          "difficulty": "Easy",
          "description": "Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.",
          "examples": [
            {
              "input": "nums = [2,7,11,15], target = 9",
              "output": "[0,1]",
              "explanation": "Because nums[0] + nums[1] == 9, we return [0, 1]."
            },
            {
              "input": "nums = [3,2,4], target = 6",
              "output": "[1,2]",
              "explanation": "Because nums[1] + nums[2] == 6, we return [1, 2]."
            }
          ],
          "constraints": [
            "2 <= nums.length <= 10^4",
            "-10^9 <= nums[i] <= 10^9",
            "-10^9 <= target <= 10^9",
            "Only one valid answer exists."
          ],
          "testCases": [
            { "input": "[2,7,11,15]\n9", "expectedOutput": "[0,1]", "hidden": false },
            { "input": "[3,2,4]\n6", "expectedOutput": "[1,2]", "hidden": false },
            { "input": "[3,3]\n6", "expectedOutput": "[0,1]", "hidden": true },
            { "input": "[2,5,5,11]\n10", "expectedOutput": "[1,2]", "hidden": true }
          ],
          "topics": ["Array", "Hash Table"],
          "companies": ["Amazon", "Google", "Apple", "Microsoft", "Facebook"]
        },
        {
          "id": 53,
          "title": "Maximum Subarray",
          "difficulty": "Medium",
          "description": "Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.",
          "examples": [
            {
              "input": "nums = [-2,1,-3,4,-1,2,1,-5,4]",
              "output": "6",
              "explanation": "[4,-1,2,1] has the largest sum = 6."
            },
            {
              "input": "nums = [1]",
              "output": "1",
              "explanation": "The array itself is the maximum subarray."
            }
          ],
          "constraints": [
            "1 <= nums.length <= 10^5",
            "-10^4 <= nums[i] <= 10^4"
          ],
          "testCases": [
            { "input": "[-2,1,-3,4,-1,2,1,-5,4]", "expectedOutput": "6", "hidden": false },
            { "input": "[1]", "expectedOutput": "1", "hidden": false },
            { "input": "[5,4,-1,7,8]", "expectedOutput": "23", "hidden": true },
            { "input": "[-1]", "expectedOutput": "-1", "hidden": true }
          ],
          "topics": ["Array", "Divide and Conquer", "Dynamic Programming"],
          "companies": ["Amazon", "Microsoft", "Apple", "Google", "Bloomberg"]
        },
        {
          "id": 121,
          "title": "Best Time to Buy and Sell Stock",
          "difficulty": "Easy",
          "description": "You are given an array prices where prices[i] is the price of a given stock on the ith day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock. Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.",
          "examples": [
            {
              "input": "prices = [7,1,5,3,6,4]",
              "output": "5",
              "explanation": "Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5."
            },
            {
              "input": "prices = [7,6,4,3,1]",
              "output": "0",
              "explanation": "In this case, no transactions are done and the max profit = 0."
            }
          ],
          "constraints": [
            "1 <= prices.length <= 10^5",
            "0 <= prices[i] <= 10^4"
          ],
          "testCases": [
            { "input": "[7,1,5,3,6,4]", "expectedOutput": "5", "hidden": false },
            { "input": "[7,6,4,3,1]", "expectedOutput": "0", "hidden": false },
            { "input": "[1,2,3,4,5]", "expectedOutput": "4", "hidden": true },
            { "input": "[2,4,1]", "expectedOutput": "2", "hidden": true }
          ],
          "topics": ["Array", "Dynamic Programming"],
          "companies": ["Amazon", "Microsoft", "Facebook", "Apple", "Google"]
        }
      ]
    },
    "string": {
      "name": "String",
      "description": "Problems involving string manipulation and algorithms",
      "questions": [
        {
          "id": 3,
          "title": "Longest Substring Without Repeating Characters",
          "difficulty": "Medium",
          "description": "Given a string s, find the length of the longest substring without repeating characters.",
          "examples": [
            {
              "input": "s = \"abcabcbb\"",
              "output": "3",
              "explanation": "The answer is \"abc\", with the length of 3."
            },
            {
              "input": "s = \"bbbbb\"",
              "output": "1",
              "explanation": "The answer is \"b\", with the length of 1."
            },
            {
              "input": "s = \"pwwkew\"",
              "output": "3",
              "explanation": "The answer is \"wke\", with the length of 3."
            }
          ],
          "constraints": [
            "0 <= s.length <= 5 * 10^4",
            "s consists of English letters, digits, symbols and spaces."
          ],
          "testCases": [
            { "input": "abcabcbb", "expectedOutput": "3", "hidden": false },
            { "input": "bbbbb", "expectedOutput": "1", "hidden": false },
            { "input": "pwwkew", "expectedOutput": "3", "hidden": false },
            { "input": "", "expectedOutput": "0", "hidden": true },
            { "input": "dvdf", "expectedOutput": "3", "hidden": true },
            { "input": "anviaj", "expectedOutput": "5", "hidden": true }
          ],
          "topics": ["Hash Table", "String", "Sliding Window"],
          "companies": ["Amazon", "Microsoft", "Facebook", "Google", "Apple"]
        },
        {
          "id": 5,
          "title": "Longest Palindromic Substring",
          "difficulty": "Medium",
          "description": "Given a string s, return the longest palindromic substring in s.",
          "examples": [
            {
              "input": "s = \"babad\"",
              "output": "\"bab\"",
              "explanation": "\"aba\" is also a valid answer."
            },
            {
              "input": "s = \"cbbd\"",
              "output": "\"bb\"",
              "explanation": "The longest palindromic substring is \"bb\"."
            }
          ],
          "constraints": [
            "1 <= s.length <= 1000",
            "s consist of only digits and English letters."
          ],
          "testCases": [
            { "input": "babad", "expectedOutput": "bab", "hidden": false },
            { "input": "cbbd", "expectedOutput": "bb", "hidden": false },
            { "input": "a", "expectedOutput": "a", "hidden": true },
            { "input": "ac", "expectedOutput": "a", "hidden": true }
          ],
          "topics": ["String", "Dynamic Programming"],
          "companies": ["Amazon", "Microsoft", "Facebook", "Apple", "Google"]
        },
        {
          "id": 20,
          "title": "Valid Parentheses",
          "difficulty": "Easy",
          "description": "Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.",
          "examples": [
            {
              "input": "s = \"()\"",
              "output": "true",
              "explanation": "The string contains valid parentheses."
            },
            {
              "input": "s = \"()[]{}\"",
              "output": "true",
              "explanation": "All brackets are properly closed."
            },
            {
              "input": "s = \"(]\"",
              "output": "false",
              "explanation": "Brackets are not properly matched."
            }
          ],
          "constraints": [
            "1 <= s.length <= 10^4",
            "s consists of parentheses only '()[]{}'."
          ],
          "testCases": [
            { "input": "()", "expectedOutput": "true", "hidden": false },
            { "input": "()[]{}", "expectedOutput": "true", "hidden": false },
            { "input": "(]", "expectedOutput": "false", "hidden": false },
            { "input": "([)]", "expectedOutput": "false", "hidden": true },
            { "input": "{[]}", "expectedOutput": "true", "hidden": true }
          ],
          "topics": ["String", "Stack"],
          "companies": ["Amazon", "Microsoft", "Facebook", "Google", "Apple"]
        }
      ]
    },
    "linkedList": {
      "name": "Linked List",
      "description": "Problems involving linked list manipulation and algorithms",
      "questions": [
        {
          "id": 2,
          "title": "Add Two Numbers",
          "difficulty": "Medium",
          "description": "You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.",
          "examples": [
            {
              "input": "l1 = [2,4,3], l2 = [5,6,4]",
              "output": "[7,0,8]",
              "explanation": "342 + 465 = 807."
            },
            {
              "input": "l1 = [0], l2 = [0]",
              "output": "[0]",
              "explanation": "0 + 0 = 0."
            }
          ],
          "constraints": [
            "The number of nodes in each linked list is in the range [1, 100].",
            "0 <= Node.val <= 9",
            "It is guaranteed that the list represents a number that does not have leading zeros."
          ],
          "testCases": [
            { "input": "[2,4,3]\n[5,6,4]", "expectedOutput": "[7,0,8]", "hidden": false },
            { "input": "[0]\n[0]", "expectedOutput": "[0]", "hidden": false },
            { "input": "[9,9,9,9,9,9,9]\n[9,9,9,9]", "expectedOutput": "[8,9,9,9,0,0,0,1]", "hidden": true }
          ],
          "topics": ["Linked List", "Math", "Recursion"],
          "companies": ["Amazon", "Microsoft", "Facebook", "Apple", "Google"]
        },
        {
          "id": 21,
          "title": "Merge Two Sorted Lists",
          "difficulty": "Easy",
          "description": "You are given the heads of two sorted linked lists list1 and list2. Merge the two lists into one sorted list. The list should be made by splicing together the nodes of the first two lists.",
          "examples": [
            {
              "input": "list1 = [1,2,4], list2 = [1,3,4]",
              "output": "[1,1,2,3,4,4]",
              "explanation": "The merged list is [1,1,2,3,4,4]."
            },
            {
              "input": "list1 = [], list2 = []",
              "output": "[]",
              "explanation": "Both lists are empty."
            }
          ],
          "constraints": [
            "The number of nodes in both lists is in the range [0, 50].",
            "-100 <= Node.val <= 100",
            "Both list1 and list2 are sorted in non-decreasing order."
          ],
          "testCases": [
            { "input": "[1,2,4]\n[1,3,4]", "expectedOutput": "[1,1,2,3,4,4]", "hidden": false },
            { "input": "[]\n[]", "expectedOutput": "[]", "hidden": false },
            { "input": "[]\n[0]", "expectedOutput": "[0]", "hidden": true }
          ],
          "topics": ["Linked List", "Recursion"],
          "companies": ["Amazon", "Microsoft", "Facebook", "Apple", "Google"]
        }
      ]
    },
    "tree": {
      "name": "Tree",
      "description": "Problems involving tree data structures and algorithms",
      "questions": [
        {
          "id": 104,
          "title": "Maximum Depth of Binary Tree",
          "difficulty": "Easy",
          "description": "Given the root of a binary tree, return its maximum depth. A binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.",
          "examples": [
            {
              "input": "root = [3,9,20,null,null,15,7]",
              "output": "3",
              "explanation": "The maximum depth is 3."
            },
            {
              "input": "root = [1,null,2]",
              "output": "2",
              "explanation": "The maximum depth is 2."
            }
          ],
          "constraints": [
            "The number of nodes in the tree is in the range [0, 10^4].",
            "-100 <= Node.val <= 100"
          ],
          "testCases": [
            { "input": "[3,9,20,null,null,15,7]", "expectedOutput": "3", "hidden": false },
            { "input": "[1,null,2]", "expectedOutput": "2", "hidden": false },
            { "input": "[]", "expectedOutput": "0", "hidden": true }
          ],
          "topics": ["Tree", "Depth-First Search", "Breadth-First Search", "Binary Tree"],
          "companies": ["Amazon", "Microsoft", "Facebook", "Apple", "Google"]
        },
        {
          "id": 226,
          "title": "Invert Binary Tree",
          "difficulty": "Easy",
          "description": "Given the root of a binary tree, invert the tree, and return its root.",
          "examples": [
            {
              "input": "root = [4,2,7,1,3,6,9]",
              "output": "[4,7,2,9,6,3,1]",
              "explanation": "The tree is inverted."
            },
            {
              "input": "root = [2,1,3]",
              "output": "[2,3,1]",
              "explanation": "The tree is inverted."
            }
          ],
          "constraints": [
            "The number of nodes in the tree is in the range [0, 100].",
            "-100 <= Node.val <= 100"
          ],
          "testCases": [
            { "input": "[4,2,7,1,3,6,9]", "expectedOutput": "[4,7,2,9,6,3,1]", "hidden": false },
            { "input": "[2,1,3]", "expectedOutput": "[2,3,1]", "hidden": false },
            { "input": "[]", "expectedOutput": "[]", "hidden": true }
          ],
          "topics": ["Tree", "Depth-First Search", "Breadth-First Search", "Binary Tree"],
          "companies": ["Amazon", "Microsoft", "Facebook", "Apple", "Google"]
        }
      ]
    },
    "dynamicProgramming": {
      "name": "Dynamic Programming",
      "description": "Problems involving dynamic programming techniques",
      "questions": [
        {
          "id": 70,
          "title": "Climbing Stairs",
          "difficulty": "Easy",
          "description": "You are climbing a staircase. It takes n steps to reach the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?",
          "examples": [
            {
              "input": "n = 2",
              "output": "2",
              "explanation": "There are two ways to climb to the top: 1. 1 step + 1 step, 2. 2 steps"
            },
            {
              "input": "n = 3",
              "output": "3",
              "explanation": "There are three ways to climb to the top: 1. 1 step + 1 step + 1 step, 2. 1 step + 2 steps, 3. 2 steps + 1 step"
            }
          ],
          "constraints": [
            "1 <= n <= 45"
          ],
          "testCases": [
            { "input": "2", "expectedOutput": "2", "hidden": false },
            { "input": "3", "expectedOutput": "3", "hidden": false },
            { "input": "4", "expectedOutput": "5", "hidden": true },
            { "input": "5", "expectedOutput": "8", "hidden": true }
          ],
          "topics": ["Math", "Dynamic Programming", "Memoization"],
          "companies": ["Amazon", "Microsoft", "Facebook", "Apple", "Google"]
        },
        {
          "id": 198,
          "title": "House Robber",
          "difficulty": "Medium",
          "description": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.",
          "examples": [
            {
              "input": "nums = [1,2,3,1]",
              "output": "4",
              "explanation": "Rob house 1 (money = 1) and then rob house 3 (money = 3). Total amount = 1 + 3 = 4."
            },
            {
              "input": "nums = [2,7,9,3,1]",
              "output": "12",
              "explanation": "Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1). Total amount = 2 + 9 + 1 = 12."
            }
          ],
          "constraints": [
            "1 <= nums.length <= 100",
            "0 <= nums[i] <= 400"
          ],
          "testCases": [
            { "input": "[1,2,3,1]", "expectedOutput": "4", "hidden": false },
            { "input": "[2,7,9,3,1]", "expectedOutput": "12", "hidden": false },
            { "input": "[2,1,1,2]", "expectedOutput": "4", "hidden": true }
          ],
          "topics": ["Array", "Dynamic Programming"],
          "companies": ["Amazon", "Microsoft", "Facebook", "Apple", "Airbnb"]
        }
      ]
    },
    "graph": {
      "name": "Graph",
      "description": "Problems involving graph algorithms and traversal",
      "questions": [
        {
          "id": 200,
          "title": "Number of Islands",
          "difficulty": "Medium",
          "description": "Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically.",
          "examples": [
            {
              "input": "grid = [[\"1\",\"1\",\"1\",\"1\",\"0\"],[\"1\",\"1\",\"0\",\"1\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"0\",\"0\"]]",
              "output": "1",
              "explanation": "There is 1 island."
            },
            {
              "input": "grid = [[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"1\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"1\",\"1\"]]",
              "output": "3",
              "explanation": "There are 3 islands."
            }
          ],
          "constraints": [
            "m == grid.length",
            "n == grid[i].length",
            "1 <= m, n <= 300",
            "grid[i][j] is '0' or '1'."
          ],
          "testCases": [
            { "input": "[[\"1\",\"1\",\"1\",\"1\",\"0\"],[\"1\",\"1\",\"0\",\"1\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"0\",\"0\"]]", "expectedOutput": "1", "hidden": false },
            { "input": "[[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"1\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"1\",\"1\"]]", "expectedOutput": "3", "hidden": false },
            { "input": "[[\"1\"]]", "expectedOutput": "1", "hidden": true },
            { "input": "[[\"0\"]]", "expectedOutput": "0", "hidden": true }
          ],
          "topics": ["Array", "Depth-First Search", "Breadth-First Search", "Union Find", "Matrix"],
          "companies": ["Amazon", "Microsoft", "Facebook", "Google", "Apple"]
        }
      ]
    },
    "backtracking": {
      "name": "Backtracking",
      "description": "Problems involving backtracking algorithms",
      "questions": [
        {
          "id": 46,
          "title": "Permutations",
          "difficulty": "Medium",
          "description": "Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.",
          "examples": [
            {
              "input": "nums = [1,2,3]",
              "output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
              "explanation": "All possible permutations of [1,2,3]."
            },
            {
              "input": "nums = [0,1]",
              "output": "[[0,1],[1,0]]",
              "explanation": "All possible permutations of [0,1]."
            }
          ],
          "constraints": [
            "1 <= nums.length <= 6",
            "-10 <= nums[i] <= 10",
            "All the integers of nums are unique."
          ],
          "testCases": [
            { "input": "[1,2,3]", "expectedOutput": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]", "hidden": false },
            { "input": "[0,1]", "expectedOutput": "[[0,1],[1,0]]", "hidden": false },
            { "input": "[1]", "expectedOutput": "[[1]]", "hidden": true }
          ],
          "topics": ["Array", "Backtracking"],
          "companies": ["Amazon", "Microsoft", "Facebook", "Apple", "Google"]
        }
      ]
    }
  },
  "difficulty": {
    "easy": [1, 20, 21, 70, 104, 121, 226],
    "medium": [2, 3, 5, 46, 53, 198, 200],
    "hard": []
  },
  "companies": {
    "Amazon": [1, 2, 3, 5, 20, 21, 46, 53, 70, 104, 121, 198, 200, 226],
    "Microsoft": [1, 2, 3, 5, 20, 21, 46, 53, 70, 104, 121, 198, 200, 226],
    "Facebook": [1, 2, 3, 5, 20, 21, 46, 53, 70, 104, 121, 198, 200, 226],
    "Google": [1, 2, 3, 5, 20, 21, 46, 53, 70, 104, 121, 198, 200, 226],
    "Apple": [1, 2, 3, 5, 20, 21, 46, 53, 70, 104, 121, 198, 200, 226]
  },
  "topics": {
    "Array": [1, 53, 121, 198, 200],
    "Hash Table": [1, 3],
    "String": [3, 5, 20],
    "Linked List": [2, 21],
    "Tree": [104, 226],
    "Dynamic Programming": [53, 70, 198],
    "Depth-First Search": [104, 200, 226],
    "Breadth-First Search": [104, 200, 226],
    "Backtracking": [46],
    "Math": [2, 70],
    "Stack": [20],
    "Sliding Window": [3],
    "Binary Tree": [104, 226],
    "Matrix": [200],
    "Union Find": [200],
    "Recursion": [2, 21],
    "Divide and Conquer": [53],
    "Memoization": [70]
  }
}
